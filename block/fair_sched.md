# Полностью честный планировщик

## Структура данных cfs_rq
(Код тяжело понять с первого раза, но удобно возвращаться по мере чтения и понимания материала)
```C
struct cfs_rq {
	struct load_weight load; // суммарная нагрузка от всех процессов
	unsigned long nr_running; // количество исполняющихся процессов для диска
	u64 min_vruntime; // минимальное виртуальное время, необходимое для инициализации виртуального таймера в новом процессе
	struct rb_root tasks_timeline; // тут хранятся в RB дереве упорядоченные по виртуальному времени процессы
	struct rb_node *rb_leftmost; // тут самый левый лист, который должен быть обслужен в первую очередь (можно получить из дерева, но так быстрее)
	struct sched_entity *curr; // сущность обслуживаемого в данный момент процесса
}
```

Все процессы в системе зависят от времени, однако информации о нем нет в структурах данных для этих процессов. Вся нужная информация вычисляется на основе реального отсчета времени (т.е. часов), а также веса (нагрузки), сопоставленного каждому процессу. \
Виртуальные часы работают с помощью функции `update_curr`, которая вызывается в множестве мест.
Суть этой функции в следующем: для начала она определяет, какой процесс выполняется в данный момент, а также смотрит на реальное время. Если текущий процесс не найден, значит, дел на данный момент нет. Иначе функция считает, сколько времени прошло с последнего визита, а затем вызывает еще одну вспомогательную функцию `__update_curr`.\
`__update_curr`, основываясь на подсчитанной ранее информации, обновляет физическое и виртуальное время, которое данный процесс затратил у процессора. \
Физическое время обновляется легко - посчитанная ранее дельта просто добавляется к ранее существующему результату.\
С виртуальным временем дело обстоит иначе. Для начала стоить упомянуть о таком понятии, как уровень процесса (nice level) - это своеобразный способ задать процессу приоритет. В случае, если уровень равен 0, виртуальное время всегда будет в точности равняться физическому по определению. Если приоритет отличен от нуля, время высчитывается по формуле:
$$delta\_weighted = delta * \frac{nice\_level\_load\_0}{curr->load.weight}$$
Главной идеей этой формулы является инвертированный вес процесса. Если приоритет процесса выше, то уровень - ниже. Таким образом, у более важных процессов виртуальное время течет медленнее. Полученная после применения формулы разность также прибавляется к уже хранящемуся счетчику виртуального времени.\
После всех подсчетов, связанных с разностью времени, функция обновляет min_vruntime. Очень важно, что данная переменная монотонно возрастает. Значение в этой переменной либо остается прежним, либо заменяется на значение vruntime текущего процесса, если оно больше. То есть, переменная либо не изменяет значения, либо увеличивает его.

Ключевым моментом всей идеи честного планировщика является сортировка на основе виртуального времени в красно-черном дереве. Элементы сортируются по неубыванию величины $$se->vruntime - cfs_rq->min\_vruntime,$$ где `se` - это независящий от процессов счетчик времени, а `cfs_rq` - это элемент, связанный с определенным процессом.\
Благодаря такой формуле выполняются 3 правила:
1. Если процесс занимает процессорное время, то его счетчик виртуального времени растет, а значит, процесс постепенно уходит в сторону конца очереди, уступая процессорное время другим.
2. Если процесс имеет высокий приоритет, то его виртуальное время растет медленнее, а это значит, что он быстрее вновь получит свой квант процессорного времени.
3. Если процесс долго находится в режиме ожидания, то его виртуальное время не меняется, а значит, разность между общим счетчиком и виртуальным временем процесса становится меньше. Таким образом, процесс движется к началу очереди и повышает свои шансы получить свой квант времени.

## Слежение за задержками
В ядре имеется свое понятие задержек - то есть, есть некий заданный интервал времени, за который каждый процесс гарантированно хотя бы раз получит свой квант процессорного времени. Он задан в переменной `sysctl_sched_latency` и по умолчанию равен 20 миллисекундам. Конечно же, в ядре также имеется переменная `sched_nr_latency`, в которой задано максимальное количество активных процессов, которое процессор способен поддерживать, не меняя вышеуказанный интервал. Если процессов становится больше, то интервал времени увеличивается линейно. \
Стоит лишний раз подчеркнуть, что данная идея подразумевает под собой нижнюю оценку отклика. Высокоприоритетные процессы в итоге получат куда большее количество процессорного времени. То есть, процессорное время будет поделено не поровну. Можно оценить количество времени, которое получит определенный процесс, посмотрев на его уровень.